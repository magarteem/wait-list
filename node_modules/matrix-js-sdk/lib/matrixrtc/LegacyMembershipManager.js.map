{"version":3,"file":"LegacyMembershipManager.js","names":["EventType","UpdateDelayedEventAction","HTTPError","MatrixError","logger","EventTimeline","sleep","DEFAULT_EXPIRE_DURATION","isLivekitFocusActive","Status","LegacyMembershipManager","callMemberEventRetryDelayMinimum","_this$joinConfig$call","_this$joinConfig","joinConfig","membershipExpiryTimeout","_this$joinConfig$memb","_this$joinConfig2","membershipServerSideExpiryTimeout","_ref","_this$membershipServe","_this$joinConfig3","membershipServerSideExpiryTimeoutOverride","membershipKeepAlivePeriod","_this$joinConfig$memb2","_this$joinConfig4","callMemberEventRetryJitter","_this$joinConfig$call2","_this$joinConfig5","constructor","room","client","getOldestMembership","_this","_defineProperty","_asyncToGenerator","updateCallMembershipRunning","needCallMembershipUpdate","updateCallMembershipEvent","knownDisconnectDelayId","disconnectDelayId","resendIfRateLimited","_unstable_updateDelayedEvent","Restart","scheduleDelayDisconnection","e","error","off","event","listener","on","isJoined","relativeExpiry","undefined","isActivated","status","Unknown","join","fociPreferred","fociActive","ownFocusActive","ownFociPreferred","triggerCallMembershipEventUpdate","leave","_arguments","arguments","_this2","timeout","length","memberEventTimeout","clearTimeout","raceResult","Promise","race","onRTCSessionMemberUpdate","memberships","_this3","isMyMembership","m","sender","getUserId","deviceId","getDeviceId","some","warn","getActiveFocus","focus_selection","oldestMembership","getPreferredFoci","makeNewMembership","makeMyMembership","_this$ownFociPreferre","call_id","scope","application","device_id","expires","focus_active","type","foci_preferred","_this4","roomState","getLiveTimeline","getState","FORWARDS","Error","roomId","localUserId","localDeviceId","newContent","stateKey","makeMembershipStateKey","prepareDelayedDisconnection","_ref4","res","_unstable_sendDelayedStateEvent","delay","GroupCallMemberPrefix","delay_id","errcode","data","maxDelayAllowed","apply","sendStateEvent","sentDelayedDisconnect","Send","info","resendDelay","Math","random","concat","setTimeout","delayDisconnection","exec","getVersion","_x","_resendIfRateLimited","func","numRetriesAllowed","isRateLimitError","defaultMs","_e$getRetryAfterMs","getRetryAfterMs"],"sources":["../../src/matrixrtc/LegacyMembershipManager.ts"],"sourcesContent":["/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { EventType } from \"../@types/event.ts\";\nimport { UpdateDelayedEventAction } from \"../@types/requests.ts\";\nimport type { MatrixClient } from \"../client.ts\";\nimport { HTTPError, MatrixError } from \"../http-api/errors.ts\";\nimport { logger } from \"../logger.ts\";\nimport { EventTimeline } from \"../models/event-timeline.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { sleep } from \"../utils.ts\";\nimport { type CallMembership, DEFAULT_EXPIRE_DURATION, type SessionMembershipData } from \"./CallMembership.ts\";\nimport { type Focus } from \"./focus.ts\";\nimport { isLivekitFocusActive } from \"./LivekitFocus.ts\";\nimport { type MembershipConfig } from \"./MatrixRTCSession.ts\";\nimport { type EmptyObject } from \"../@types/common.ts\";\nimport { type IMembershipManager, type MembershipManagerEvent, Status } from \"./types.ts\";\n\n/**\n * This internal class is used by the MatrixRTCSession to manage the local user's own membership of the session.\n *\n * Its responsibitiy is to manage the locals user membership:\n *  - send that sate event\n *  - send the delayed leave event\n *  - update the delayed leave event while connected\n *  - update the state event when it times out (for calls longer than membershipExpiryTimeout ~ 4h)\n *\n * It is possible to test this class on its own. The api surface (to use for tests) is\n * defined in `MembershipManagerInterface`.\n *\n * It is recommended to only use this interface for testing to allow replacing this class.\n *\n * @internal\n * @deprecated Use {@link MembershipManager} instead\n */\nexport class LegacyMembershipManager implements IMembershipManager {\n    private relativeExpiry: number | undefined;\n\n    private memberEventTimeout?: ReturnType<typeof setTimeout>;\n\n    /**\n     *   This is a Foci array that contains the Focus objects this user is aware of and proposes to use.\n     */\n    private ownFociPreferred?: Focus[];\n    /**\n     *   This is a Focus with the specified fields for an ActiveFocus (e.g. LivekitFocusActive for type=\"livekit\")\n     */\n    private ownFocusActive?: Focus;\n\n    private updateCallMembershipRunning = false;\n    private needCallMembershipUpdate = false;\n    /**\n     * If the server disallows the configured {@link membershipServerSideExpiryTimeout},\n     * this stores a delay that the server does allow.\n     */\n    private membershipServerSideExpiryTimeoutOverride?: number;\n    private disconnectDelayId: string | undefined;\n\n    private get callMemberEventRetryDelayMinimum(): number {\n        return this.joinConfig?.callMemberEventRetryDelayMinimum ?? 3_000;\n    }\n    private get membershipExpiryTimeout(): number {\n        return this.joinConfig?.membershipExpiryTimeout ?? DEFAULT_EXPIRE_DURATION;\n    }\n    private get membershipServerSideExpiryTimeout(): number {\n        return (\n            this.membershipServerSideExpiryTimeoutOverride ??\n            this.joinConfig?.membershipServerSideExpiryTimeout ??\n            8_000\n        );\n    }\n    private get membershipKeepAlivePeriod(): number {\n        return this.joinConfig?.membershipKeepAlivePeriod ?? 5_000;\n    }\n    private get callMemberEventRetryJitter(): number {\n        return this.joinConfig?.callMemberEventRetryJitter ?? 2_000;\n    }\n\n    public constructor(\n        private joinConfig: MembershipConfig | undefined,\n        private room: Pick<Room, \"getLiveTimeline\" | \"roomId\" | \"getVersion\">,\n        private client: Pick<\n            MatrixClient,\n            | \"getUserId\"\n            | \"getDeviceId\"\n            | \"sendStateEvent\"\n            | \"_unstable_sendDelayedStateEvent\"\n            | \"_unstable_updateDelayedEvent\"\n        >,\n        private getOldestMembership: () => CallMembership | undefined,\n    ) {}\n\n    public off(\n        event: MembershipManagerEvent.StatusChanged,\n        listener: (oldStatus: Status, newStatus: Status) => void,\n    ): this {\n        logger.error(\"off is not implemented on LegacyMembershipManager\");\n        return this;\n    }\n\n    public on(\n        event: MembershipManagerEvent.StatusChanged,\n        listener: (oldStatus: Status, newStatus: Status) => void,\n    ): this {\n        logger.error(\"on is not implemented on LegacyMembershipManager\");\n        return this;\n    }\n\n    public isJoined(): boolean {\n        return this.relativeExpiry !== undefined;\n    }\n    public isActivated(): boolean {\n        return this.isJoined();\n    }\n    /**\n     * Unimplemented\n     * @returns Status.Unknown\n     */\n    public get status(): Status {\n        return Status.Unknown;\n    }\n\n    public join(fociPreferred: Focus[], fociActive?: Focus): void {\n        this.ownFocusActive = fociActive;\n        this.ownFociPreferred = fociPreferred;\n        this.relativeExpiry = this.membershipExpiryTimeout;\n        // We don't wait for this, mostly because it may fail and schedule a retry, so this\n        // function returning doesn't really mean anything at all.\n        void this.triggerCallMembershipEventUpdate();\n    }\n\n    public async leave(timeout: number | undefined = undefined): Promise<boolean> {\n        this.relativeExpiry = undefined;\n        this.ownFocusActive = undefined;\n\n        if (this.memberEventTimeout) {\n            clearTimeout(this.memberEventTimeout);\n            this.memberEventTimeout = undefined;\n        }\n        if (timeout) {\n            // The sleep promise returns the string 'timeout' and the membership update void\n            // A success implies that the membership update was quicker then the timeout.\n            const raceResult = await Promise.race([this.triggerCallMembershipEventUpdate(), sleep(timeout, \"timeout\")]);\n            return raceResult !== \"timeout\";\n        } else {\n            await this.triggerCallMembershipEventUpdate();\n            return true;\n        }\n    }\n\n    public async onRTCSessionMemberUpdate(memberships: CallMembership[]): Promise<void> {\n        const isMyMembership = (m: CallMembership): boolean =>\n            m.sender === this.client.getUserId() && m.deviceId === this.client.getDeviceId();\n\n        if (this.isJoined() && !memberships.some(isMyMembership)) {\n            logger.warn(\"Missing own membership: force re-join\");\n            // TODO: Should this be awaited? And is there anything to tell the focus?\n            return this.triggerCallMembershipEventUpdate();\n        }\n    }\n\n    public getActiveFocus(): Focus | undefined {\n        if (this.ownFocusActive) {\n            // A livekit active focus\n            if (isLivekitFocusActive(this.ownFocusActive)) {\n                if (this.ownFocusActive.focus_selection === \"oldest_membership\") {\n                    const oldestMembership = this.getOldestMembership();\n                    return oldestMembership?.getPreferredFoci()[0];\n                }\n            } else {\n                logger.warn(\"Unknown own ActiveFocus type. This makes it impossible to connect to an SFU.\");\n            }\n        } else {\n            // We do not understand the membership format (could be legacy). We default to oldestMembership\n            // Once there are other methods this is a hard error!\n            const oldestMembership = this.getOldestMembership();\n            return oldestMembership?.getPreferredFoci()[0];\n        }\n    }\n\n    private triggerCallMembershipEventUpdate = async (): Promise<void> => {\n        // TODO: Should this await on a shared promise?\n        if (this.updateCallMembershipRunning) {\n            this.needCallMembershipUpdate = true;\n            return;\n        }\n\n        this.updateCallMembershipRunning = true;\n        try {\n            // if anything triggers an update while the update is running, do another update afterwards\n            do {\n                this.needCallMembershipUpdate = false;\n                await this.updateCallMembershipEvent();\n            } while (this.needCallMembershipUpdate);\n        } finally {\n            this.updateCallMembershipRunning = false;\n        }\n    };\n    private makeNewMembership(deviceId: string): SessionMembershipData | EmptyObject {\n        // If we're joined, add our own\n        if (this.isJoined()) {\n            return this.makeMyMembership(deviceId);\n        }\n        return {};\n    }\n\n    /**\n     * Constructs our own membership\n     */\n    private makeMyMembership(deviceId: string): SessionMembershipData {\n        return {\n            call_id: \"\",\n            scope: \"m.room\",\n            application: \"m.call\",\n            device_id: deviceId,\n            expires: this.relativeExpiry,\n            focus_active: { type: \"livekit\", focus_selection: \"oldest_membership\" },\n            foci_preferred: this.ownFociPreferred ?? [],\n        };\n    }\n\n    private async updateCallMembershipEvent(): Promise<void> {\n        if (this.memberEventTimeout) {\n            clearTimeout(this.memberEventTimeout);\n            this.memberEventTimeout = undefined;\n        }\n\n        const roomState = this.room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        if (!roomState) throw new Error(\"Couldn't get room state for room \" + this.room.roomId);\n\n        const localUserId = this.client.getUserId();\n        const localDeviceId = this.client.getDeviceId();\n        if (!localUserId || !localDeviceId) throw new Error(\"User ID or device ID was null!\");\n\n        let newContent: EmptyObject | SessionMembershipData = {};\n        // TODO: add back expiary logic to non-legacy events\n        // previously we checked here if the event is timed out and scheduled a check if not.\n        // maybe there is a better way.\n        newContent = this.makeNewMembership(localDeviceId);\n\n        try {\n            if (this.isJoined()) {\n                const stateKey = this.makeMembershipStateKey(localUserId, localDeviceId);\n                const prepareDelayedDisconnection = async (): Promise<void> => {\n                    try {\n                        const res = await resendIfRateLimited(() =>\n                            this.client._unstable_sendDelayedStateEvent(\n                                this.room.roomId,\n                                {\n                                    delay: this.membershipServerSideExpiryTimeout,\n                                },\n                                EventType.GroupCallMemberPrefix,\n                                {}, // leave event\n                                stateKey,\n                            ),\n                        );\n                        this.disconnectDelayId = res.delay_id;\n                    } catch (e) {\n                        if (\n                            e instanceof MatrixError &&\n                            e.errcode === \"M_UNKNOWN\" &&\n                            e.data[\"org.matrix.msc4140.errcode\"] === \"M_MAX_DELAY_EXCEEDED\"\n                        ) {\n                            const maxDelayAllowed = e.data[\"org.matrix.msc4140.max_delay\"];\n                            if (\n                                typeof maxDelayAllowed === \"number\" &&\n                                this.membershipServerSideExpiryTimeout > maxDelayAllowed\n                            ) {\n                                this.membershipServerSideExpiryTimeoutOverride = maxDelayAllowed;\n                                return prepareDelayedDisconnection();\n                            }\n                        }\n                        logger.error(\"Failed to prepare delayed disconnection event:\", e);\n                    }\n                };\n\n                await prepareDelayedDisconnection();\n                // Send join event _after_ preparing the delayed disconnection event\n                await resendIfRateLimited(() =>\n                    this.client.sendStateEvent(this.room.roomId, EventType.GroupCallMemberPrefix, newContent, stateKey),\n                );\n                // If sending state cancels your own delayed state, prepare another delayed state\n                // TODO: Remove this once MSC4140 is stable & doesn't cancel own delayed state\n                if (this.disconnectDelayId !== undefined) {\n                    try {\n                        const knownDisconnectDelayId = this.disconnectDelayId;\n                        await resendIfRateLimited(() =>\n                            this.client._unstable_updateDelayedEvent(\n                                knownDisconnectDelayId,\n                                UpdateDelayedEventAction.Restart,\n                            ),\n                        );\n                    } catch (e) {\n                        if (e instanceof MatrixError && e.errcode === \"M_NOT_FOUND\") {\n                            // If we get a M_NOT_FOUND we prepare a new delayed event.\n                            // In other error cases we do not want to prepare anything since we do not have the guarantee, that the\n                            // future is not still running.\n                            logger.warn(\"Failed to update delayed disconnection event, prepare it again:\", e);\n                            this.disconnectDelayId = undefined;\n                            await prepareDelayedDisconnection();\n                        }\n                    }\n                }\n                if (this.disconnectDelayId !== undefined) {\n                    this.scheduleDelayDisconnection();\n                }\n                // TODO throw or log an error if this.disconnectDelayId === undefined\n            } else {\n                // Not joined\n                let sentDelayedDisconnect = false;\n                if (this.disconnectDelayId !== undefined) {\n                    try {\n                        const knownDisconnectDelayId = this.disconnectDelayId;\n                        await resendIfRateLimited(() =>\n                            this.client._unstable_updateDelayedEvent(\n                                knownDisconnectDelayId,\n                                UpdateDelayedEventAction.Send,\n                            ),\n                        );\n                        sentDelayedDisconnect = true;\n                    } catch (e) {\n                        logger.error(\"Failed to send our delayed disconnection event:\", e);\n                    }\n                    this.disconnectDelayId = undefined;\n                }\n                if (!sentDelayedDisconnect) {\n                    await resendIfRateLimited(() =>\n                        this.client.sendStateEvent(\n                            this.room.roomId,\n                            EventType.GroupCallMemberPrefix,\n                            {},\n                            this.makeMembershipStateKey(localUserId, localDeviceId),\n                        ),\n                    );\n                }\n            }\n            logger.info(\"Sent updated call member event.\");\n        } catch (e) {\n            const resendDelay = this.callMemberEventRetryDelayMinimum + Math.random() * this.callMemberEventRetryJitter;\n            logger.warn(`Failed to send call member event (retrying in ${resendDelay}): ${e}`);\n            await sleep(resendDelay);\n            await this.triggerCallMembershipEventUpdate();\n        }\n    }\n\n    private scheduleDelayDisconnection(): void {\n        this.memberEventTimeout = setTimeout(() => void this.delayDisconnection(), this.membershipKeepAlivePeriod);\n    }\n\n    private readonly delayDisconnection = async (): Promise<void> => {\n        try {\n            const knownDisconnectDelayId = this.disconnectDelayId!;\n            await resendIfRateLimited(() =>\n                this.client._unstable_updateDelayedEvent(knownDisconnectDelayId, UpdateDelayedEventAction.Restart),\n            );\n            this.scheduleDelayDisconnection();\n        } catch (e) {\n            logger.error(\"Failed to delay our disconnection event:\", e);\n        }\n    };\n\n    private makeMembershipStateKey(localUserId: string, localDeviceId: string): string {\n        const stateKey = `${localUserId}_${localDeviceId}`;\n        if (/^org\\.matrix\\.msc(3757|3779)\\b/.exec(this.room.getVersion())) {\n            return stateKey;\n        } else {\n            return `_${stateKey}`;\n        }\n    }\n}\n\nasync function resendIfRateLimited<T>(func: () => Promise<T>, numRetriesAllowed: number = 1): Promise<T> {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        try {\n            return await func();\n        } catch (e) {\n            if (numRetriesAllowed > 0 && e instanceof HTTPError && e.isRateLimitError()) {\n                numRetriesAllowed--;\n                let resendDelay: number;\n                const defaultMs = 5000;\n                try {\n                    resendDelay = e.getRetryAfterMs() ?? defaultMs;\n                    logger.info(`Rate limited by server, retrying in ${resendDelay}ms`);\n                } catch (e) {\n                    logger.warn(\n                        `Error while retrieving a rate-limit retry delay, retrying after default delay of ${defaultMs}`,\n                        e,\n                    );\n                    resendDelay = defaultMs;\n                }\n                await sleep(resendDelay);\n            } else {\n                throw e;\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}